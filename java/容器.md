### HashMap: 当链表长度大于阈值(默认为8),(将链表转换成红黑树前会判断，如果当前数组（默认16）的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树），将链表转化为红黑树，以减少搜索时间。当红黑树小于6会退化为链表
- TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。
- 如果我们的根节点选择是最小或者最大的数，那么二叉查找树就完全退化成了线性结构和顺序查找差不多。

### HashMap 的长度为什么是2的幂次方
(n-1)&hash: 如果n是2的幂次方那么采用二进制位与操作&，相对于%能够提高运算效率，能让HashMap存取高效，尽量较少hash碰撞，也就是要尽量把数据分配均匀。

### HashMap为什么扩容为之前的2倍


### HashMap是先插入还是先扩容
HashMap初始化后首次插入数据时，先发生resize扩容再插入数据，之后每当插入的数据个数达到threshold时就会发生resize，此时是先插入数据再resize。

### HashMap死循环致使服务器cpu飙升至100%
JDK1.8以前在多线程下，进行put操作会导致HashMap死循环，原因在于HashMap的扩容resize()方法。由于扩容是新建一个数组，复制原数据到数组。由于数组下标挂有链表，但是多线程操作可能导致环形链表。JDK1.8已经解决了此问题(声明两对指针(loHead,loTail)，维护两个链表(hiHead,hiTail)依次在末端添加新的元素。（在多线程操作的情况下，无非是第二个线程重复第一个线程一模一样的操作）)