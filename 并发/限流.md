  限流算法：

  令牌桶和漏桶对比：
    令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；
    漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；
    令牌桶限制的是平均流入速率，允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌；漏桶限制的是常量流出速率，即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2，从而平滑突发流入速率；
  令牌桶允许一定程度的突发，而漏桶主要目的是平滑流出速率；
    Guava的RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。
    RateLimiter使用令牌桶算法，会进行令牌的累积，如果获取令牌的频率比较低，则不会导致等待，直接获取令牌。由于会累积令牌，所以可以应对突发流量。
    在没有足够令牌发放时，采用滞后处理的方式，也就是前一个请求获取令牌所需等待的时间由下一次请求来承受，也就是代替前一个请求进行等待。
    SmoothWarmingUp实现预热缓冲的关键在于其分发令牌的速率会随时间和令牌数而改变，速率会先慢后快。
        //SmoothRateLimiter.java
        //当前存储令牌数
        double storedPermits;
        //最大存储令牌数
        double maxPermits;
        //添加令牌时间间隔
        double stableIntervalMicros;
        /**
        * 下一次请求可以获取令牌的起始时间
        * 由于RateLimiter允许预消费，上次请求预消费令牌后
        * 下次请求需要等待相应的时间到nextFreeTicketMicros时刻才可以获取令牌
        */
        private long nextFreeTicketMicros = 0L;


Bloom Filter 概念
  布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。
  它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

原理：
  布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。
缺点：
  bloom filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性
存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。
删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用Counting Bloom Filter，建立白名单存错误信息。

bitmap：
  应用场景：
    统计上亿的日活跃用户
      1.为了统计今日登录的用户数，我们建立了一个bitmap,每一位标识一个用户ID。当某个用户访问我们的网页或执行了某个操作，就在bitmap中把标识此用户的位置为1。在Redis中获取此bitmap的key值是通过用户执行操作的类型和时间戳获得的。
      2.这个简单的例子中，每次用户登录时会执行一次redis.setbit(daily_active_users, user_id, 1)。将bitmap中对应位置的位置为1，时间复杂度是O(1)。统计bitmap结果显示有今天有9个用户登录。Bitmap的key是daily_active_users，它的值是1011110100100101。
      3.因为日活跃用户每天都变化，所以需要每天创建一个新的bitmap。我们简单地把日期添加到key后面，实现了这个功能。例如，要统计某一天有多少个用户至少听了一个音乐app中的一首歌曲，可以把这个bitmap的redis key设计为play:yyyy-mm-dd-hh。当用户听了一首歌曲，我们只是简单地在bitmap中把标识这个用户的位置为1，时间复杂度是O(1)。


秒杀活动存储过程：
  -- 秒杀执行储存过程
```
DELIMITER
$$
-- 定义储存过程
-- 参数: in 参数,out输出参数
-- row_count() 返回上一条修改类型sql(delete,insert,update)的影响行数
-- row_count:0:未修改数据, >0:表示修改的行数, <0:sql错误
CREATE PROCEDURE `seckill`.`execute_seckill`
  (IN v_seckill_id BIGINT, IN v_phone BIGINT,IN v_kill_time  TIMESTAMP, OUT r_result INT)
  BEGIN
    -- 定义一个变量为insert_count，记录插入数量
    DECLARE insert_count INT DEFAULT 0;
    -- 开始事务
    START TRANSACTION;
    -- 插入秒杀成功信息
    INSERT IGNORE INTO success_killed
    (seckill_id, user_phone, create_time)
    VALUES (v_seckill_id, v_phone, v_kill_time);
    -- 查询影响行数
    SELECT row_count()
    -- 将影响行数赋值给insert_count
    INTO insert_count;
    -- 判断执行状态
    IF (insert_count = 0)
    -- 如果=0未修改数据，事务回滚，并设置返回结果
    THEN
      ROLLBACK;
      SET r_result = -1;
    ELSEIF (insert_count < 0)
    -- 如果<0sql报错，事务回滚，并设置返回结果
      THEN
        ROLLBACK;
        SET r_result = -2;
    ELSE
    -- 如果大于0，执行成功，更改秒杀数量
      UPDATE seckill
      SET number = number - 1
      WHERE seckill_id = v_seckill_id
            AND end_time > v_kill_time
            AND start_time < v_kill_time
            AND number > 0;
      -- 查询更改秒杀数量结果
      SELECT row_count()
      -- 将秒杀数量结果赋值给insert_count
      INTO insert_count;
      -- 判断修改秒杀数量执行结果
      IF (insert_count = 0)
      -- 如果=0sql未修改记录，回滚事务，并设置返回结果
      THEN
        ROLLBACK;
        SET r_result = 0;
      ELSEIF (insert_count < 0)
      -- 如果<0sql报错，回滚事务，并设置返回结果
        THEN
          ROLLBACK;
          SET r_result = -2;
      ELSE
      -- 如果>0修改秒杀数量成功，提交事务，并设置返回结果
        COMMIT;
        SET r_result = 1;

      END IF;
    END IF;
  END;
$$
--  储存过程定义结束
DELIMITER ;
SET @r_result = -3;
--  执行储存过程
CALL execute_seckill(1003, 13502178891, now(), @r_result);
-- 获取结果
SELECT @r_result;
```
