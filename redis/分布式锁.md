# redis分布式锁

### 普通锁：
```lua
- 获取锁（unique_value可以是UUID等）
SET resource_name unique_value NX PX 30000
- 释放锁（lua脚本中，一定要比较value，防止误解锁）
if redis.call("get",KEYS[1]) == ARGV[1] then
return redis.call("del",KEYS[1])
else
return 0
end
```

#### 这种实现方式有3大要点（面试概率非常高的地方）：
- set命令要用set key value nx px milliseconds ；
- value要具有唯一性；
- 释放锁时要验证value值，不能误解锁；
- 事实上这类琐最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：
    1. 在Redis的master节点上拿到了锁；
    2. 但是这个加锁的key还没有同步到slave节点；
    3. master故障，发生故障转移，slave节点升级为master节点；导致锁丢失。

### redLock:
   - 在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。我们确保将在N个实例上使用与在Redis单实例下相同方法获取和释放锁。现在我们假设有5个Redis master节点，同时我们需要在5台服务器上面运行这些Redis实例，这样保证他们不会同时都宕掉。为了取到锁，客户端应该执行以下操作:
      1. 获取当前Unix时间，以毫秒为单位。[开始获取锁时间]
      2. 依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。
      3. 客户端使用最后一次获取锁时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁花费的总的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且花费的时间小于锁失效时间时，锁才算获取成功。[获取锁使用时间=最后获取锁时间-开始获取锁时间]
      4. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间。[锁有效时间=有效时间-获取锁使用时间]
      5. 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。
   - 加锁的流程：（lua：一堆命令保证原子性）
      1. 判断lock键是否存在，不存在直接调用hset存储当前线程信息并且设置过期时间,返回nil，告诉客户端直接获取到锁。
      2. 判断lock键是否存在，存在则判断是否是同一线程，如果是将重入次数加1，并重新设置过期时间，返回nil，告诉客户端直接获取到锁。
      3. 如果不是，代表锁被其它线程已经锁定，返回锁有效期的剩余时间，告诉客户端需要等待。
   - 解锁的流程：
      1. 解锁的流程看起来复杂些：
      2. 如果lock键不存在，发消息说锁已经可用
      3. 如果锁存在，且锁不是被当前线程锁定，则返回nil
      4. 线程id相同，由于支持可重入，在解锁时将重入次数需要减1
      5. 如果计算后的重入次数>0，则重新设置过期时间
      6. 如果计算后的重入次数<=0，则发消息说锁已经可用

####  redlock缺点：

    1.RedLock中，为了防止死锁，锁是具有过期时间的。如果 Client 1 在持有锁的时候，发生了一次很长时间的 FGC 超过了锁的过期时间。锁就被释放了。这个时候 Client 2 又获得了一把锁，提交数据。这个时候 Client 1 从 FGC 中苏醒过来了，又一次提交数据。RedLock 只是保证了锁的高可用性，并没有保证锁的正确性。
    
    2.RedLock 是一个 严重依赖系统时钟 的分布式系统。Client 1 从 A、B、C、D、E五个节点中，获取了 A、B、C三个节点获取到锁，我们认为他持有了锁,这个时候，由于 B 的系统时间比别的系统走得快，B就会先于其他两个节点优先释放锁。Clinet 2 可以从 B、D、E三个节点获取到锁。在整个分布式系统就造成 两个 Client 同时持有锁了。

### redisson看门狗机制
- redisson加锁成功后节点崩溃了，这个锁正好处于锁定的状态，redisson有看门狗每隔10秒不断延长锁的有效期
- 当锁超过了失效时间但是业务还没有处理完，看门狗机制也可以延迟锁的失效时间



---