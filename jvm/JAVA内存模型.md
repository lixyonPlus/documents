JAVA内存模型：
  有序性、可见性、原子性
  导致可见性的原因是缓存，导致有序性的原因是编译优化
  涉及 volatile、synchronized、final 以及 6项Happens-Before规则
  Happens-Benfore：前面一个操作的结果对后续的操作是可见的。
    1.程序顺序性规则：在一个线程中，按照程序顺序Happers-Before于后续操作可见。
    2.volatile变量规则：对一个volatile变量的写操作，Happens-Before于后续对这个Volatile变量的读操作。
    3.传递性：如果A Happens-Before B，且B Happens-Before C，那么A Happens-Before C。
    4.管程中的锁（synchronized）规则：对一个锁的解锁Happens-Before于后续对这个锁的加锁，管程是一种通用的同步原语，在java中指的是synchronized，是java对管程的实现。
    5.线程start（）规则：主线程序A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作。
    6.线程join（）规则：主线程A等待子线程B完成，子线程B完成后，主线程能够看到子线程的操作。
    7.线程interrupt（）规则：对线程interrupt（）的方法的调用先行发生于被中断的线程的代码检测到中断的事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。
    8.对象终结规则： 一个对象的初始化完成（构造方法执行结束）先行发生于他的finalize（）方法的开始。
    final：变量生而不变，
    volatile：目的是为了禁用缓存和编译优化。
  java内存模型是如何实现的：主要通过内存屏障禁止重排序，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的cpu指令。
  synchronized：修饰静态方法时锁定的是当前类的class对象，修饰非静态方法时，锁定的是当前实例对象this。

在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用;Java中根据其生命周期的长短，将引用分为4类。
1 强引用
 特点:我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误(OOM)，使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。
2 软引用
特点:软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象:即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列(ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用 队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。
应用场景:软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
3 弱引用
弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会 回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾 回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
应用场景:弱应用同样可用于内存敏感的缓存。
4 虚引用
特点:虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 fnalize 以后，做某些事情的机制。如果 一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 (ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如 果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
ReferenceQueue queue = new ReferenceQueue ();
PhantomReference pr = new PhantomReference (object, queue);
程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之
前采取一些程序行动。
应用场景:可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。

1 String
  (1) String的创建机制，由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。
      其运行机制是:创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用;如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。
      举例:String str1 = "123"; //通过直接量赋值方式，放入字符串常量池
      String str2 = new String(“123”);//通过new方式赋值方式，不放入字符串常量池
      注意:String提供了inter()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串(由equals方法确定)，则返回池中的字符串。否则，将此String对象添加到池中，并且 返回此池中对象的引用。
  (2) String的特性
    [A] 不可变。是指String对象一旦生成，则不能再对它进行改变。不可变的主要作用在于当一个对象需要被多线程共享，并且访问频繁时，可以省略同步和锁等待的时间，从而大幅度提高系统性能。不可变模   式是一个可以提高多线程程序的性能，降低多线程程序复杂度的设计模式。
    [B] 针对常量池的优化。当2个String对象拥有相同的值时，他们只引用常量池中的同一个拷贝。当同一个字符串反复出现时，这个技术可以大幅度节省内存空间。
2 StringBufer/StringBuilder
  StringBufer和StringBuilder都实现了AbstractStringBuilder抽象类，拥有几乎一致对外提供的调用接口;其底层在内存中的存储方式与String相同，都是以一个有序的字符序列(char类型 的数组)进行存储，不同点是StringBufer/StringBuilder对象的值是可以改变的，并且值改变以后，对象引用不会发生改变;两者对象在构造过程中，首先按照默认大小申请一个字符数组，由 于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评 估大小，可提升性能。
  唯一需要注意的是:StringBufer是线程安全的，但是StringBuilder是线程不安全的。可参看Java标准类库的源代码，StringBufer类中方法定义前面都会有synchronize关键字。为 此，StringBufer的性能要远低于StringBuilder。
3 应用场景 
  [A]在字符串内容不经常发生变化的业务场景优先使用String类。例如:常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用String与String之间的“+”操作，因为这
  样会产生大量无用的中间对象，耗费空间且执行效率低下(新建对象、回收对象花费大量时间)。
  [B]在频繁进行字符串的运算(如拼接、替换、删除等)，并且运行在多线程环境下，建议使用StringBufer，例如XML解析、HTTP参数解析与封装。
  [C]在频繁进行字符串的运算(如拼接、替换、删除等)，并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、JSON封装等。


  反射中Class.forName()和ClassLoader.loadClass()的区别：
  Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);
  第2个boolean参数表示类是否需要初始化，  Class.forName(className)默认是需要初始化。
  一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。

  ClassLoader.loadClass(className)方法，内部实际调用的方法是  ClassLoader.loadClass(className,false);
  false表示不进行链接，不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行


JVM：

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域:
  对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。
  HotSpot虚拟机的对象头包括两部分信息，
    第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32bit和64bit，官方称它为"Mark Word"。
    另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，另外如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。
  实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 
  对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。 

JVM类加载机制分为五个部分：加载，链接（验证，准备，解析），初始化
  加载：是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。 
  验证：这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 
  准备：准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： public static int v = 8080; 
  实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的put static指令是程序被编译后，存放于类构造器<client>方法之中。 但是注意如果声明为：
  public static final int v = 8080; 
  在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。 
  解析：解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：
    1. CONSTANT_Class_info
    2. CONSTANT_Field_info 
    3. CONSTANT_Method_info 等类型的常量。 
    符号引用：符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 
    直接引用：直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 
  初始化：初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。 
    类构造器<client> ：
      初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。 
    注意以下几种情况不会执行类初始化： 
       1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
       2. 定义对象数组，不会触发该类的初始化。 
       3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
       4. 通过类名获取Class对象，不会触发类的初始化。 
       5. 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
       6. 通过ClassLoader默认的loadClass方法，也不会触发初始化动作。


1 int和Integer
  JDK1.5引入了自动装箱与自动拆箱功能，Java可根据上下文，实现int/Integer,double/Double,boolean/Boolean 等基本类型与相应对象之间的自动转换，为开发过程带来极大便利。
  最常用的是通过new方法构建Integer对象。但是，基于大部分数据操作都是集中在有限的、较小的数值范围，在JDK1.5 中新增了静态工厂方法 valueOf，其背后实现是将int值为-128 到 127 之间的Integer对象进行缓存，在调用时候直接从缓存中获取，进而提升构建对象的性能，也就是说使用该方法后，如果两个对象的int值相同且落在缓存值范围内，那么这个两个对象就是同一个对象;当值较小且频繁使用时，推荐优先使用整型池方法(时间与空间性能俱佳)。
2 注意事项
  [1] 基本类型均具有取值范围，在大数*大数的时候，有可能会出现越界的情况。
  [2] 基本类型转换时，使用声明的方式。例:long result= 1234567890 * 24 * 365;结果值一定不会是你所期望的那个值，因为1234567890 * 24已经超过了int的范围，如果修改 为:long result= 1234567890L * 24 * 365;就正常了。
  [3] 慎用基本类型处理货币存储。如采用double常会带来差距，常采用BigDecimal、整型(如果要精确表示分，可将值扩大100倍转化为整型)解决该问题。
  [4] 优先使用基本类型。原则上，建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，
  [5] 如果有线程安全的计算需要，建议考虑使用类型AtomicInteger、AtomicLong 这样的线程安全类。部分比较宽的基本数据类型，比如 float、double，甚至不能保证更新操作的原子性， 可能出现程序读取到只更新了一半数据位的数值。

as-if-serial
  不管如何重排序，都必须保证代码在单线程下的运行正确。

重排序（volatile、synchronized、final、Lock）
  定义：重排序是指“编译器和处理器”为了提高性能，而在程序执行时会对程序进行的重排序。
  说明：重排序分为——“编译器”和“处理器”两个方面，而“处理器”重排序又包括“指令级重排序”和“内存的重排序”。
  关于重排序，我们需要理解它的思想：为了提高程序的并发度，从而提高性能！但是对于多线程程序，重排序可能会导致程序执行的结果不是我们需要的结果！因此，就需要我们通过“volatile，synchronize，锁等方式”作出正确的实现同步。

内存屏障
  定义：包括LoadLoad, LoadStore, StoreLoad, StoreStore共4种内存屏障。内存屏障是与相应的内存重排序相对应的。
  作用：通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。

分配内存： new 出来的对象不一定都分配在堆上，其中有 栈上分配（逃逸分析）和 tlab （线程本地分配缓存区）。
  栈上分配：
    逃逸分析：对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束。（分配栈上）
    标量替换：允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。
  tlab： 线程私有的 （eden区tlab分配）

JVM会先进行栈上分配，不符合会进行tlab分配，如果tlab分配不成功在尝试在eden区分配，如果对象满足了直接进入老年代的条件，直接分配老年代。

分配内存的两种方法： 指针碰撞和空闲列表
  指针碰撞：假设JVM虚拟机上，堆内存都是规整的。堆内存被一个指针一分为二。指针的左边都被塞满了对象，指针的右变是未使用的区域。每一次有新的对象创建，指针就会向右移动一个对象size的距离。这就被称为指针碰撞。
  空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）

JVM内存区域：
  线程私有： 程序计数器、栈、本地方法栈
  栈帧：局步变量表、操作数栈、动态链接、方法出口
  线程共享： 堆、metaspace（元空间）、直接内存（堆外内存）
  堆： 新生代（eden）、老年代、运行时常量池（符号引用（类完全限定名、字段名称描述符、方法名称描述符）、字面量：字符串、final常量、基本数据类型、其他）

如何确定对象是不是垃圾： 引用计数，可达性分析
  引用计数：一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。
  可达性分析：如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

复制算法：新生代，每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集. 
标记复制算法：老年代，因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存. 

CMS收集器（多线程标记清除算法）：
  CMS收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。  
  CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段： 
    1。初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
    2。并发标记 进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
    3。重新标记 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。 
    4。并发清除 清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。

G1收集器 Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果。
相比与CMS收集器，G1收集器两个最突出的改进是： 
  1. 基于标记-整理算法，不产生内存碎片。 
  2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 
G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率

-xms -xmx 设置成一样的值，不会动态调整内存大小。

volatile
作用: 如果一个变量是volatile类型，则对该变量的读写就将具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。volatile变量自身具有下列特性：
  [可见性]：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
  [原子性]：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。
  volatile的内存语义:
  volatile写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。
  volatile读：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
  volatile和 synchronize对比:
  在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。
  volatile仅仅保证对单个volatile变量的读/写具有原子性；而synchronize锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。

JMM通过“内存屏障”实现final,在final域的写之后，构造函数return之前，插入一个StoreStore障屏。在读final域的操作前面插入一个LoadLoad屏障。

重排序分三种类型：
编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
