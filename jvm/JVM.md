## JVM虚拟机
### 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域:
  - 对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)
  #### HotSpot虚拟机的对象头包括两部分信息:
    1. 第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32bit和64bit，官方称它为"Mark Word"。
    2. 另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，另外如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。
  #### 实例数据:
    1. 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。 
  #### 对齐填充:
    1.对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。

### JVM类加载机制分为五个部分：
- 加载，链接（验证，准备，解析），初始化
  #### 加载：
  - 是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。 
  #### 验证：
  - 这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 
  #### 准备：
  - 准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： public static int v = 8080; 实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的put static指令是程序被编译后，存放于类构造器`<client>`方法之中。 但是注意如果声明为：public static final int v = 8080; 在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。 
  #### 解析：
    - 解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：
      1.CONSTANT_Class_info
      2. CONSTANT_Field_info 
      3. CONSTANT_Method_info 等类型的常量
  #### 初始化：
  - 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。
  - 类构造器<client> ：初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。 注意以下几种情况不会执行类初始化： 
           1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
           2. 定义对象数组，不会触发该类的初始化。 
           3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
           4. 通过类名获取Class对象，不会触发类的初始化。 
           5. 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
           6. 通过ClassLoader默认的loadClass方法，也不会触发初始化动作。

   #### 符号引用：
   - 符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
   #### 直接引用：
   - 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。
 

### 分配内存： new 出来的对象不一定都分配在堆上，其中有栈上分配（逃逸分析）和 tlab （[堆中eden区]线程本地分配缓存区）。
  - 栈上分配：
    1. 逃逸分析：对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束。（分配栈上）
    2. 标量替换：允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。
  - tlab： 线程私有的 （eden区tlab分配）

#### JVM会先进行栈上分配，不符合会进行tlab分配，如果tlab分配不成功在尝试在eden区分配，如果对象满足了直接进入老年代的条件，直接分配老年代。

#### 分配内存的两种方法： 指针碰撞和空闲列表
  - 指针碰撞：假设JVM虚拟机上，堆内存都是规整的。堆内存被一个指针一分为二。指针的左边都被塞满了对象，指针的右变是未使用的区域。每一次有新的对象创建，指针就会向右移动一个对象size的距离。这就被称为指针碰撞。
  - 空闲列表：如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）

### JVM内存区域：
  #### 线程私有： 
    - 程序计数器:字节码的行号指示器（分支、循环、跳转、异常处理、线程恢复），唯一不会发生内存溢出的区域。
    - 虚拟机栈
       - 栈帧：局步变量表（基本数据类型、对象引用、returnAddress类型）、操作数栈、动态链接、方法出口
    - 本地方法栈
  #### 线程共享： 堆、metaspace（元空间）【运行时常量池（符号引用（类完全限定名、字段名称描述符、方法名称描述符）、字面量：字符串、final常量、基本数据类型、其他）】、直接内存（堆外内存）
    - 堆：新生代（eden，fromSurvivor，toSurvivor）、老年代







#### 如何确定对象是不是垃圾： 引用计数、可达性分析
  - 引用计数：一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。
  - 可达性分析：如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

#### 复制算法：新生代，每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集. 
#### 标记复制算法：老年代，因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存. 

### CMS收集器（多线程标记清除算法）：
  #### CMS收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段： 
    1.初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
    2.并发标记 进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
    3.重新标记 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。 
    4.并发清除 清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。

#### G1收集器 Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果。相比与CMS收集器，G1收集器两个最突出的改进是： 
    1. 基于标记-整理算法，不产生内存碎片。 
    2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 
  - G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集 时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率

#### -xms -xmx 设置成一样的值，不会动态调整内存大小。


