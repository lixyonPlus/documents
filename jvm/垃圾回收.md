# 垃圾回收
![](https://images.xiaozhuanlan.com/photo/2020/ed7c818bba22ff5f8338fa0854021bcf.png)

### 针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：
1. 部分收集 (Partial GC)：
新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
2. 整堆收集 (Full GC)：收集整个Java堆和方法区。

#### 如何确定对象是不是垃圾： 引用计数、可达性分析
  - 引用计数：一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。【废弃】
  - 可达性分析：如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

#### 可以作为GC ROOT的对象有：栈中引用的对象，方法区中静态引用的对象和常量池中引用的对象、Native引用的对象。

### 如何判断一个常量是废弃常量?
运行时常量池主要回收的是废弃的常量。那么我们如何判断一个常量是废弃常量呢？假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

### 如何判断一个类是无用的类?
判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 “无用的类” ：
1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。



--- 

# 垃圾回收算法

####  标记-清除算法: 该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：效率问题,空间问题（标记清除后会产生大量不连续的碎片）

#### 复制算法：新生代，每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集. 

#### 标记整理算法：老年代，因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清除”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存. 

#### 分代回收：当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。


---
# 垃圾收集器
![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/41460955.jpg)

### Serial 收集器(复制算法)
Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。

### ParNew 收集器(复制算法)
ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

###  Parallel Scavenge 收集器(复制算法)
Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

### JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能

### Serial Old收集器(复制算法)
Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

### Parallel Old 收集器（多线程标记-整理算法）
Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

### CMS垃圾收集器默认GC最大年龄时是6

### CMS收集器（多线程标记-清除算法）
CMS收集器是一种老年代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。

### CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段： 
![](https://images.xiaozhuanlan.com/photo/2020/9238539c9071f598e8de7e8fd0d5bd1a.jpg)
1. 初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，需要暂停所有的工作线程。
2. 并发标记：进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
3. 重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要暂停所有的工作线程。 
4. 并发清除：清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户线程一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。


### CMS不会等到应用程序饱和的时候才去回收垃圾，而是在某一阀值(默认为68)的时候开始回收，也就是说当老年代的空间使用率达到68%的时候回执行CMS。如果内存使用率增长很快，在CMS执行过程中，已经出现了内存不足的情况，此时，CMS回收就会失败，虚拟机将启动老年代串行回收器进行垃圾回收，这会导致应用程序中断，直到垃圾回收完成后才会正常工作，这个过程GC的停顿时间可能较长，所以阀值的设置要根据实际情况设置。
  
### 三色标记算法
    白：对象没有被标记到
    灰：对象被标记了，但是它的field还没有被标记或标记完
    黑：对象被标记了，且它的所有field也被标记完了

#### CMS标记会存在多标和漏标的情况：多标的称为浮动垃圾等待下一轮标记，漏标的用读写屏障解决。

### CMS写屏障
CMS在并发标记这个过程中，垃圾回收线程和应用线程是同时在跑的，这导致有些对象会从新生代晋升到老年代、有些老年代的对象引用会被改变、有些对象会直接分配到老年代，而这些在内存中修改引用会触发写屏障脏卡，也就是这些受到影响的老年代对象所在的Card会被标记为脏卡（Dirty Card），而在JVM卡表中，每512Byte大小的内存页与卡表中一个Byte关联。因此不是脏内存页没有指向新生代的引用。这意味我们仅仅可以扫描脏内存页中的对象，不需要扫描整个老年代。


#### G1收集器 Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果。
将堆内存分成大小相等的region，region大小取值为1到32M，默认region个数为2048个。
- 初始标记：这个阶段仅仅只是标记GC Roots能直接关联到的对象并修改TAMS
- 并发标记
- 最终标记
- 筛选回收

#### G1的SATB算法机制中，会在GC开始时先创建一个对象快照，在并发标记时所有快照中当时的存活对象就认为是存活的，标记过程中新分配的对象也会被标记为存活对象，不会被回收。这种机制能够很好解决新创建对象漏标的情况。STAB核心的两个结构就是两个Bitmap。Bitmap分别存储在每个Region中，并发标记过程里的两个重要的变量：preTAMS(pre-top-at-mark-start，代表着Region上一次完成标记的位置) 以及nextTAMS（next-top-at-mark-start，随着标记的进行会不断移动，一开始在top位置）。

### G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First的由来)。这种使用 Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

#### 相比与CMS收集器，G1收集器两个最突出的改进是： 
  1. 基于标记-整理算法，不产生内存碎片。 
  2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 
  - G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率

#### -xms -xmx 设置成一样的值，不会动态调整内存大小。

#### JVM内存不要超过32G
    JVM 在内存小于32GB的时候会采用一个内存对象指针压缩技术。一旦你越过32GB的边界，指针就会切回普通对象的指针。每个对象的指针都变长了，就会使用更多的CPU内存带宽，也就是说你实际上失去了更多的内存。

#### 内存泄漏与内存溢出区别
    内存溢出：系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出
    内存泄漏：如果这块内存不释放，就不能再用了，这就叫这块内存泄漏了

#### JVM什么时候发生FullGC
    System.gc()
    老年代空间不足
    堆中分配很大的对象
    CMS GC时出现promotion failed和concurrent mode failure
    HandlePromotionFailure：在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。
    




