# 垃圾回收
![](https://images.xiaozhuanlan.com/photo/2020/ed7c818bba22ff5f8338fa0854021bcf.png)

### 针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：
1. 部分收集 (Partial GC)：
新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
2. 整堆收集 (Full GC)：收集整个Java堆和方法区。

#### 如何确定对象是不是垃圾： 引用计数、可达性分析
  - 引用计数：一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。【废弃】
  - 可达性分析：如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

#### 可以作为GC ROOT的对象有：（私有变量）栈中引用的对象，方法区中静态引用的对象和常量池中引用的对象、Native引用的对象。

### oopmap
- 一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象GC Roots,使用OopMap可以避免全栈扫描，加快枚举根节点的速度。

### 记忆集与卡表
- 如果老年代有对象引用了新生代对象，那么老年代的对象也应该加入gc roots的范围中，但是如果每次进行young gc我们都需要扫描一次老年代的话，那我们进行垃圾回收的代价实在是太大了，因此我们引入了一种叫做记忆集的抽象数据结构来记录这种引用关系。
- 记忆集是我们针对于跨代引用问题提出的思想，而卡表则是针对于该种思想的具体实现。（可以理解为记忆集是结构，卡表是实现类）
- 在hotspot虚拟机中，卡表是一个字节数组，数组的每一项对应着内存中的某一块连续地址的区域，如果该区域中有引用指向了待回收区域的对象，卡表数组对应的元素将被置为1，没有则置为0；下图为卡表的一个实现，某块内存的地址向右移动9位(相当于除以512)定位到一个卡表元素，也就是说，内存中每512字节的连续区域会被定位到同一片卡表区域，如果卡表对应元素为1则代表该512个字节所在区域中有指向的指针。

### 写屏障
- 我们每次对引用进行改变时，我们在程序中并没有手动去维护卡表的信息，这就依赖于我们的写屏障功能。
- 写屏障可以理解为对于我们引用类型字段复制的AOP操作。在赋前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的部分的写屏障叫作写后屏障（PostWrite Barrier）。



### 如何判断一个常量是废弃常量?
运行时常量池主要回收的是废弃的常量。那么我们如何判断一个常量是废弃常量呢？假如在常量池中存在字符串 "abc"，如果当前没有任何String对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

### 如何判断一个类是无用的类?
判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 “无用的类” ：
1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。



--- 

# 垃圾回收算法

####  标记-清除算法: 该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：效率问题,空间问题（标记清除后会产生大量不连续的碎片）

#### 复制算法：新生代，每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集. 

#### 标记整理算法：老年代，因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清除”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存. 

#### 分代回收：当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。


---
# 垃圾收集器
![](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/41460955.jpg)

### Serial 收集器(复制算法)
Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。

### ParNew 收集器(复制算法)
ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

### Parallel Scavenge 收集器(复制算法)
Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。

### Serial Old收集器(复制算法)
Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge 收集器搭配使用，另一种用途是作为CMS收集器的后备方案。

### Parallel Old 收集器（多线程标记-整理算法）
Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge 收集器和 Parallel Old 收集器。


### JDK1.8默认使用的是Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能

### CMS垃圾收集器默认GC最大年龄时是6

### 对象每经历一次MinorGC年龄+1,默认最大年龄15(自定义: -XX:MaxTenuringThreshold)


### CMS收集器（多线程标记-清除算法）
CMS收集器是一种老年代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。

### CMS工作机制整个过程分为以下4个阶段： 
![](https://images.xiaozhuanlan.com/photo/2020/9238539c9071f598e8de7e8fd0d5bd1a.jpg)
1. 初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，需要暂停所有的工作线程。
2. 并发标记：进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
3. 重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要暂停所有的工作线程。 
4. 并发清除：清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户线程一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。


### CMS不会等到应用程序饱和的时候才去回收垃圾，而是在某一阀值(默认为92%)的时候开始回收，也就是说当老年代的空间使用率达到92%的时候会执行CMS GC。如果内存使用率增长很快，在CMS GC执行过程中，已经出现了内存不足的情况，此时，CMS回收就会失败，虚拟机将启动老年代串行回收器进行垃圾回收，这会导致应用程序中断，直到垃圾回收完成后才会正常工作，这个过程GC的停顿时间可能较长，所以阀值的设置要根据实际情况设置。
  

### 三色标记算法
- 初始状态，所有的对象都是白色的，只有 GC Roots 是黑色的。
- 白：对象没有被标记到
- 灰：对象被标记了，但是它的field还没有被标记或标记完
- 黑：对象被标记了，且它的所有field也被标记完了

### 三色标记根据可达性分析算法，从GC Roots开始进行遍历访问。
- 初始标记阶段，GC Roots标记直接关联对象置为灰色。
- 并发标记阶段，扫描整个引用链。
  - 没有子节点的话，将本节点变为黑色。
  - 有子节点的话，则当前节点变为黑色，子节点变为灰色。
- 重复并发标记阶段，直至灰色对象没有其它子节点引用时结束。
- 扫描完成 此时黑色对象就是存活的对象，白色对象就是已消亡可回收的对象。

#### CMS多标的称为浮动垃圾等待下一轮标记，漏标的用增量更新解决，G1用原始快照解决漏标。

### CMS promotion failed（晋升失败）
- promotion failed是在进行Minor GC(年轻代GC)时，Survivor Space放不下，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年带有足够的空闲空间，但是由于碎片较多，这时如果新生代要转移到老年代的对象比较大，所以，必须尽可能提早触发老年带的CMS回收来避免这个问题（promotion failed时老年带CMS还没有机会进行回收，又放不下转移到老年带的对象，因此会出现下一个问题concurrent mode failure，需要stop-the-wold GC- Serail Old）
 - 优化方法: 让CMS在进行一定次数的Full GC（标记清除）的时候进行一次标记整理算法，CMS提供了以下参数来控制: -XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction=5
也就是CMS在进行5次Full GC（标记清除）之后进行一次标记整理算法，从而可以控制老年代的碎片在一定的数量以内，甚至可以配置CMS在每次Full GC的时候都进行内存的整理。


### CMS concurrent mode failure（并发更新失败）
- concurrent mode failure是在执行CMS GC的过程中同时业务线程将对象放入老年代，而此时老年代空间不足，这时CMS还没有机会回收老年代产生的垃圾对象，或者在做MinorGC(年轻代GC)的时候，年轻代survivor空间放不下，需要放入老年代，而老年代也放不下而产生的。concurrent mode failure出现的频率，这可以通过-XX:+PrintGCDetails来观察，当出现concurrent mode failure的现象时，就意味着此时JVM将继续采用Stop-The-World（使用Serail old）的方式来进行Full GC，这种情况下，CMS就没什么意义了.
- 解决这个问题的通用方法是调低触发CMS GC执行的阀值，CMS GC触发主要由CMSInitiatingOccupancyFraction值决定，默认情况是当老年代已用空间为92%(JDK8以上)时，即触发CMS GC，在出现concurrent mode failure的情况下，可考虑调小这个值，提前CMS GC的触发，以保证旧生代有足够的空间。
  - (JDK8以上)CMSInitiatingOccupancyFraction默认值为-1,MinHeapFreeRatio默认为40,CMSTriggerRatio默认为80，当CMSInitiatingOccupancyFraction大于等于0时，使用自定义CMSInitiatingOccupancyFraction值，当CMSInitiatingOccupancyFraction小于0此时根据计算公式((100-MinHeapFreeRatio)+(tr*MinHeapFreeRatio)/100)/100 = 92%


### G1收集器 
- G1将堆内存“化整为零”，将堆内存划分成多个大小相等独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。Region可能是Eden，也有可能是Survivor，也有可能是Old，另外Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围为1MB~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的进行回收大多数情况下都把Humongous Region作为老年代的一部分来进行看待。

### 垃圾回收过程
将堆内存分成大小相等的region，region大小取值为1到32M，默认region个数为2048个。
- 初始标记(Initial Marking)：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。 
- 并发标记( Concurrent Marking)：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫
描完成以后，并发时有引用变动的对象会产生漏标问题，G1中会使用SATB(snapshot-at-the-beginning)算法来解决，后面会详细介绍。 
- 最终标记(Final Marking)：对用户线程做一个短暂的暂停，用于处理并发标记阶段仍遗留下来的最后那少量的SATB记录(漏标对象)。 
- 筛选回收(Live Data Counting and Evacuation)：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。
- TAMS是什么？要达到GC与用户线程并发运行，必须要解决回收过程中新对象的分配，所以G1为每一个Region区域设计了两个名为TAMS（Top at Mark Start）的指针，从Region区域划出一部分空间用于记录并发回收过程中的新对象。这样的对象认为它们是存活的，不纳入垃圾回收范围。


#### G1的SATB算法机制中，会在GC开始时先创建一个对象快照，在并发标记时所有快照中当时的存活对象就认为是存活的，标记过程中新分配的对象也会被标记为存活对象，不会被回收。这种机制能够很好解决新创建对象漏标的情况。STAB核心的两个结构就是两个Bitmap。Bitmap分别存储在每个Region中，并发标记过程里的两个重要的变量：preTAMS(pre-top-at-mark-start，代表着Region上一次完成标记的位置) 以及nextTAMS（next-top-at-mark-start，随着标记的进行会不断移动，一开始在top位置）。

### G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First的由来)。这种使用 Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

#### 相比与CMS收集器，G1收集器两个最突出的改进是： 
  1. 基于标记-整理算法，不产生内存碎片。 
  2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 
  - G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率

#### -xms -xmx 设置成一样的值，不会动态调整内存大小。

#### JVM内存不要超过32G
    JVM 在内存小于32GB的时候会采用一个内存对象指针压缩技术。一旦你越过32GB的边界，指针就会切回普通对象的指针。每个对象的指针都变长了，就会使用更多的CPU内存带宽，也就是说你实际上失去了更多的内存。

#### 内存泄漏与内存溢出区别
    内存溢出：系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出
    内存泄漏：如果这块内存不释放，就不能再用了，这就叫这块内存泄漏了

#### JVM什么时候发生FullGC
    System.gc()
    老年代空间不足
    堆中分配很大的对象
    CMS GC时出现promotion failed和concurrent mode failure
    HandlePromotionFailure：在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。
    




