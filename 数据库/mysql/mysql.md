
### 什么是快照读(一致性读)和当前读？
- 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析) 利用mvcc解决
  - select * from table where ?;

- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。
  - select * from table where ? lock in share mode;
  - select * from table where ? for update;
  - insert into table values (…);
  - update table set ? where ?;
  - delete from table where ?;


### mysql中如何解决幻读？
- 在快照读读情况下，mysql通过mvcc来避免幻读。
- 在当前读情况下，mysql通过gap(间隙锁)来避免幻读



## MVCC(Mutil-Version Concurrency Control)
- 就是多版本并发控制。MVCC是一种并发控制的方法，在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。这就使得别的事务可以修改这条记录，每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。


## 版本链
- 通过当前最新记录（聚簇索引）、undo日志组成版本链
- 在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列。
  1. trx_id :这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。
  2. roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)
  

## ReadView
- ReadView中主要就是有个列表来存储我们系统中当前活跃着的事务（未提交的事物）、最小事物id、下一个事物id、创建ReadView的事物id，通过这个列表来判断版本链中记录的版本是否对当前事务可见。

- 有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

  - 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。

  - 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。

  - 如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。

  - 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

  - 如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。




## ReadCommited(读已提交)和RepeatableRead(可重复读)生成readView区别?
- 已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView（解决幻读）。


# 锁
- select不加锁(对于普通select查询innodb不加锁)
- 读锁、S锁
- 写锁、X锁
- 表锁(X锁、X锁)
- GAP锁（间隙锁）
- Next Key Lock(包含间隙锁和X锁)


#### select... lock in share mode
- 将查询到的数据加一个S锁，允许其他记录继续获取这些记录的S锁，不能获取这些记录的X锁（会阻塞）
- 使用场景： 读出数据后，其他事物不能修改，但是自己也不一定能修改，因为其他事物也可以使用“select...lock in share mode” 继续加读锁。

#### select... for update
- 将查询到的数据加一个X锁，不允许其他事物获取这些记录的X锁或S锁。
- 使用场景：读出数据后，其他事物都不能写，也不能加读锁，只有自己可以修改数据。


### 写操作
#### delete：删除记录时，先对记录加X锁，再执行删除操作。
#### insert：插入记录时，会先加“隐式锁”来保护这条新插入的数据再本事物提交前不被别的事物访问到。
#### update：
- 如果被更新的列，修改前后没有导致存储空间变化，会先给记录加X锁，再直接对记录修改。
- 如果被更新的列，修改前后导致存储空间发生了变化，那么会先给记录加X锁，然后将记录删除，在insert一条新记录。

#### 隐式锁：一个事物插入一条记录后，还未提交，这条记录会保存本次事物ID，而其他事物想来对这个记录加锁会发现事物id不对应，这时会产生X锁，所以在插入一条记录之前会隐式的给这条记录加一把隐式锁。

### 行锁
 - lock_rec_not_gap:单个行记录上的锁。

### 间隙锁
 - gap lock： 锁定一个范围，但不包括记录本身，gap锁的目的，是为了防止同一事物的两次当前读，出现幻读的情况。
 - next-key lock：锁定一个范围并锁定的记录本身。对于行的查询都是采用该方法，主要目的为了解决幻读问题。



### count(*)/count(1)/count(字段)的区别？
因为COUNT(*)是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供COUNT(*) 查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。当然，这些优化的前提都是没有进行where和group的条件查询。
在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样。
但是COUNT( 字段 )需要进行字段的非NULL判断，所以效率会低一些。


### sql执行流程
1. 客户端发送sql给服务器
2. 服务器检查缓存中是否存在该查询，若存在则直接返回
3. 服务器进行sql解析、语法检测、预处理，优化器生成对应的执行计划
4. 执行器根据执行计划调用存储引擎接口执行
5. 执行结果返回。
![](https://s3.ax1x.com/2021/03/10/6GacCR.png)

### mysql中innodb会出现死锁，myisam不会出现死锁（表锁一次性获取了所有的锁）

### B+树
1. 聚簇索引非叶子节点只存储主键+页号（二级索引非叶子节点存储索引+主键+页号）。
2. 所有节点记录之间都有一个链指针(单链表)。
3. 数据记录都存放在叶子节点中。
4. 所有节点(页)之间有双向链表。


### mysql表空间被划分为许多连续的区，每个区默认由64个页组成（每页默认16KB），每256个区划分为一组

### redo log
- 语句在执行过程中可能修改若干个页面。比如一条INSERT语句可能修改系统表空间页号为7的页面的Max Row ID属性(当然也可能更新别的系统页面，只不过我们没有都列举出来而已)，还会更新聚簇索引和二级索引对应B+树中的页面。由于对这些页面的更改都发生在Buffer Pool中，所以在修改完页面之后，需要记录一下相应的redo日志,把通过mtr(mini-transaction)生成的redo日志都放在了大小为512字节的页中。在执行语句的过程中产生的redo日志被划分成了若干个不可分割的组,一个事务可以包含若干条语句，每一条语句其实是由若干个mtr(mini-transaction)组成，每一个mtr又可以包含若干条redo日志

### 事务id是怎么生成的
- 服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务id时，就会把该变量的值当作事务id分配给该事务，并且把该变量自增1。
每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为5的页面中一个称之为Max Trx ID的属性处，这个属性占用8个字节的存储 空间。
当系统下一次重新启动时，会将上边提到的Max Trx ID属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量(因为在上次关机时该全局 变量的值可能大于Max Trx ID属性值)。

### 自增id怎么生成的
- 同事物id一样，只是系统表空间页号为7


### insert undo日志在事务提交之后就可以被释放掉了，而update undo日志由于还需要支持MVCC，不能立即删除掉。

