
### mysql中如何解决幻读？
- 在快照读读情况下，mysql通过mvcc来避免幻读。
- 在当前读读情况下，mysql通过next-key来避免幻读

### 什么是快照读和当前读？
- 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)
 - select * from table where ?;
- 当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。
  - select * from table where ? lock in share mode;
  - select * from table where ? for update;
  - insert into table values (…);
  - update table set ? where ?;
  - delete from table where ?;

## MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。MVCC 是一种并发控制的方法，在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。这就使得别的事务可以修改这条记录，每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。

## 版本链：在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列。
1. trx_id :这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。
2. roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)

## ReadView：ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。


## 已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。


# 锁
- 读锁、S锁
- 写锁、X锁
- select不加锁
  
### 读操作
- 对于普通select查询innodb不加锁。
#### select... lock in share mode
- 将查询到的数据加一个S锁，允许其他记录继续获取这些记录的S锁，不能获取这些记录的X锁（会阻塞）
- 使用场景： 读出数据后，其他事物不能修改，但是自己也不一定能修改，因为其他事物也可以使用“select...lock in share mode” 继续加读锁。

#### select... for update
- 将查询到的数据加一个X锁，不允许其他事物获取这些记录的X锁或S锁。
- 使用场景：读出数据后，其他事物都不能写，也不能加读锁，只有自己可以修改数据。

#### （读已提交）使用主键索引、唯一索引、普通索引、没用索引时，只会对查询出的记录加锁。写不会加锁。
#### （可重复读）使用主键索引、唯一索引、普通索引、没用索引时，只会对查询出的记录加锁。写会加锁。（间隙锁，防止幻读）


### 写操作
#### delete：删除记录时，先对记录加X锁，再执行删除操作。
#### insert：插入记录时，会先加“隐式锁”来保护这条新插入的数据再本事物提交前不被别的事物访问到。
#### update：
- 如果被更新的列，修改前后没有导致存储空间变化，怎么会先给记录加X锁，再直接对记录修改。
- 如果被更新的列，修改前后导致存储空间发生了变化，那么会先给记录加X锁，然后将记录删除，在insert一条新记录。

#### 隐式锁：一个事物插入一条记录后，还未提交，这条记录会保存本次事物ID，而其他事物想来对这个记录加锁会发现事物id不对应，这时会产生X锁，所以在插入一条记录之前会隐式的给这条记录加一把隐式锁。

### 行锁
 - lock_rec_not_gap:单个行记录上的锁。

### 间隙锁
 - gap lock： 锁定一个范围，但不包括记录本身，gap锁的目的，是为了防止同一事物的两次当前读，出现幻读的情况。
 - next-key lock：锁定一个范围并锁定的记录本身。对于行的查询都是采用该方法，主要目的为了解决幻读问题。



### count(*)/count(1)/count(字段)的区别？
因为COUNT(*)是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供COUNT(*) 查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。当然，这些优化的前提都是没有进行where和group的条件查询。
在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样。
但是COUNT( 字段 )需要进行字段的非NULL判断，所以效率会低一些。


### sql执行流程
1. 客户端发送sql给服务器
2. 服务器检查缓存中是否存在该查询，若存在则直接返回
3. 服务器进行sql解析、语法检测、预处理，优化器生成对应的执行计划
4. 执行器根据执行计划调用存储引擎接口执行
5. 执行结果返回。
![](https://s3.ax1x.com/2021/03/10/6GacCR.png)

### mysql中innodb会出现死锁，myisam不会出现死锁（表锁一次性获取了所有的锁）

### B+树
1. 非叶子节点只存储键值信息。
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中。