# mysql事物：

## MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。MVCC 是一种并发控制的方法，在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。这就使得别的事务可以修改这条记录，每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。


## 版本链：在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列。
1. trx_id :这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。
2. roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)

## ReadView：ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。


## 已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。


# 锁
- 读锁、S锁
- 写锁、X锁
- select不加锁
  
### 读操作
- 对于普通select查询innodb不加锁。
#### select... lock in share mode
- 将查询到的数据加一个S锁，允许其他记录继续获取这些记录的S锁，不能获取这些记录的X锁（会阻塞）
- 使用场景： 读出数据后，其他事物不能修改，但是自己也不一定能修改，因为其他事物也可以使用“select...lock in share mode” 继续加读锁。

#### select... for update
- 将查询到的数据加一个X锁，不允许其他事物获取这些记录的X锁或S锁。
- 使用场景：读出数据后，其他事物都不能写，也不能加读锁，只有自己可以修改数据。

#### （读已提交）使用主键索引、唯一索引、普通索引、没用索引时，只会对查询出的记录加锁。写不会加锁。
#### （可重复读）使用主键索引、唯一索引、普通索引、没用索引时，只会对查询出的记录加锁。写会加锁。（间隙锁，防止幻读）


### 写操作
#### delete：删除记录时，先对记录加X锁，再执行删除操作。
#### insert：插入记录时，会先加“隐式锁”来保护这条新插入的数据再本事物提交前不被别的事物访问到。
#### update：
- 如果被更新的列，修改前后没有导致存储空间变化，怎么会先给记录加X锁，再直接对记录修改。
- 如果被更新的列，修改前后导致存储空间发生了变化，那么会先给记录加X锁，然后将记录删除，在insert一条新记录。

#### 隐式锁：一个事物插入一条记录后，还未提交，这条记录会保存本次事物ID，而其他事物想来对这个记录加锁会发现事物id不对应，这时会产生X锁，所以在插入一条记录之前会隐式的给这条记录加一把隐式锁。

### 行锁
 - lock_rec_not_gap:单个行记录上的锁。
 - lock_gap:间隙锁，锁定一个范围，但不包括记录本身，gap锁的目的，是为了防止同一事物的两次当前读，出现幻读的情况。
 - lock_ordinary:锁定一个范围并锁定的记录本身。对于行的查询都是采用该方法，主要目的为了解决幻读问题。


### count(*)/count(1)/count(字段)的区别？
因为COUNT(*)是SQL92定义的标准统计行数的语法，所以MySQL对他进行了很多优化，MyISAM中会直接把表的总行数单独记录下来供COUNT(*) 查询，而InnoDB则会在扫表的时候选择最小的索引来降低成本。当然，这些优化的前提都是没有进行where和group的条件查询。
在InnoDB中COUNT(*)和COUNT(1)实现上没有区别，而且效率一样。
但是COUNT( 字段 )需要进行字段的非NULL判断，所以效率会低一些。

### 在mysql中，提供了两种事务隔离技术，第一个是mvcc，第二个是next-key技术。这个在使用不同的语句的时候可以动态选择。不加lock inshare mode之类的就使用mvcc。否则使用next-key。mvcc的优势是不加锁，并发性高。缺点是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。同时需要注意几点：1.事务的快照时间点是以第一个select来确认的。所以即便事务先开始。但是select在后面的事务的update之类的语句后进行，那么它是可以获取后面的事务的对应的数据。2.mysql中数据的存放还是会通过版本记录一系列的历史数据，这样，可以根据版本查找数据。